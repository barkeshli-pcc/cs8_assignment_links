<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Assignment: 11_90_b_plus_tree</title>
<link rel="stylesheet" href="modern-style.css">

</head>
<body>
<h2 style="text-align: center;"><strong>B+ Tree Class</strong></h2>
<p>&nbsp;</p>
<h3>&nbsp;</h3>
<p><strong> <img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.dropbox.com/s/v3c5kpmqjrxf4au/Screenshot%202017-11-08%2009.54.16.png?dl=1" loading="lazy"> </strong></p>
<p><strong>NOTE:&nbsp;</strong>As you may have discovered in the BTree project that bugs in array functions prove detrimental to the success of your project. Please test these functions well.</p>
<h3><strong>Introduction:</strong></h3>
<pre><span class="comment">/*
 * ------------------------------------------------------------------------
 * 000 B_PLUS_TREE:
 *                               [   40 | 60   ]
 *                       /              |              \
 *                  [20]              [50]               [ 70 | 80 ]
 *                /      \           /    \              /    |     \
 *           [0|10] -&gt; [20|30] -&gt;  [40] -&gt; [50] -&gt;   [60] -&gt; [70] -&gt; [80|90]
 *
 *  data[i] of every node is the same key as subset[i+1]-&gt;leftmost node's data[0]
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 * is_valid():
 *  check to see if all B+ tree conditions are met with the current (sub)tree:
 * if is_leaf: return true;
 * if (data[last item] is NOT &lt;= all subset[last subtree]-&gt;data
 *      return false;
 * for every data[i]
 *      if data[i] is NOT &gt; all subset[i]-&gt;data
 *          return false;
 * //now, this is lame:
 * for every data[i]
 *      if data[i] is not in the leaves
 *          return false;
 *
 * for every subtree subset[i]
 *      if !subset[i]-&gt;is_valid()
 *          return false;
 * . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 *
 * find (contain, get, etc.):
 *  try finding the key in this node.
 *  if found:
 *      if is_leaf: then you're done
 *      else recursively call subset[i+1]-&gt;find()
 *  else
 *      recursively call subset[i]-&gt;find()
 *
 *
 * . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 * insert:
 *  call loose_insert
 *  grow the tree if you need to.
 *
 * loose_insert(entry):
 *  look for entry in data [ ]
 *  if found and no dupes, exit.
 *  four cases:
 *      1. found / leaf: call overloaded +
 *      2. found / !leaf call subset[i+1]-&gt;loose_insert and fix_excess(i+1)
 *      3. !found / leaf insert entry at position data[i]
 *      4. !found / !leaf call subset[i]-&gt;loose_insert and fix_excess(i)
 *
 * fix_excess: when you split, insert middle item up to  data[i].
 *                  [20]
 *                /      \              + 25
 *           [0|10] -&gt; [20|30] -&gt;|||
 *
 *                   [20]
 *                 /      \
 *           [0|10] -&gt; [20|25|30] -&gt;|||

 *
 *    insert 25: split [20, 25, 30]: COPY middle item up to data[i]
 *                     [20|25]
 *                /       |      \
 *           [0|10] -&gt; [20|25] -&gt; [30] -&gt;|||
 *
 *     is_leaf(): Detach the last item (25) from the left subset (subset[i]) and insert it
 *                into the left of subset[i+1]
 *
 *                     [20|25]
 *                /       |      \
 *           [0|10] -&gt;  [20] -&gt; [25|30] -&gt;|||
 *
 * . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 *
 * remove(entry):
 *  call loose_remove(entry)
 *  shrink the tree if you need to.
 *
 *
 *                     [20|25]
 *                /       |      \
 *           [0|10] -&gt;  [20] -&gt; [25|30] -&gt;|||
 *
 * loose_remove:
 *  1. if this node is_leaf: just delete and return. if not found, then not on tree
 *  2. if found (and this node not is_leaf):
 *      if shortage, fix shortage
 *                   look for entry in this subset and replace it (data[i]) with smallest of subset[i+1]
 *                   else look for entry in the subset resulting from fix_shortage
 *                                     and replace it with that subset's smallest
 * 3. if not found (yet) call loose_remove of the subset[i] and fix shortage if needed.
 *
 *
 *
 * BPlusTree* fix_shortage(i): fixing shortage in subset[i] of this node:
 *
 *  1. transfer_right(i-1)
 *  2. transfer_left(i+1)
 *  3. merge_with_next_subset(i-1)
 *  4. merge_with_next_subset(i)
 *
 *  (all these functions edit/remove data[i] and could adjust next pointer)
 *
 *  return the resulting subset back to loose_remove
 * .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
 *
 * transfer_left
 * note: when in transfer left, subset[i-1] is being fixed
 * transfer subset[i]-&gt;data[0] to the end of subset[i-1]
 * data[i-1] is updated with subset[i]-&gt;data[0]
 *
 * transfer_right:
 * when in transfer right, subset[i+1] is being fixed
 * transfer subset[i]'s last data[ ] to the beginning of subset[i+1]
 * data[i] is updated with subset[i+1]-&gt;data[0]
 * .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
 * merge_with_next_subset:
 *  leaf or non-leaf are the same, except, with leaf nodes, deleted data[i]
 *
 * -------------------------------------------------------------------------
 */</span></pre>
<h3><strong>class BPlusTree:</strong></h3>
<div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008800;">template</span> <span style="color: #333333;">&lt;</span><span style="color: #008800;">class</span> <span style="color: #bb0066;">T</span><span style="color: #333333;">&gt;</span>
<span style="color: #008800;">class</span> <span style="color: #bb0066;">BPlusTree</span>
{
<span style="color: #997700;">public:</span>
    <span style="color: #008800;">class</span> <span style="color: #bb0066;">Iterator</span>{
    <span style="color: #997700;">public:</span>
        <span style="color: #008800;">friend</span> <span style="color: #008800;">class</span> <span style="color: #bb0066;">BPlusTree</span>;
        Iterator(BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;*</span> _it<span style="color: #333333;">=</span><span style="color: #007020;">NULL</span>, <span style="color: #333399;">int</span> _key_ptr <span style="color: #333333;">=</span> <span style="color: #0000dd;">0</span>)<span style="color: #333333;">:</span>
                                                it(_it), key_ptr(_key_ptr){}

        T <span style="color: #008800;">operator</span> <span style="color: #333333;">*</span>();

        Iterator <span style="color: #008800;">operator</span><span style="color: #333333;">++</span>(<span style="color: #333399;">int</span> un_used);
        Iterator <span style="color: #008800;">operator</span><span style="color: #333333;">++</span>();
        <span style="color: #008800;">friend</span> <span style="color: #333399;">bool</span> <span style="color: #008800;">operator</span> <span style="color: #333333;">==</span>(<span style="color: #008800;">const</span> Iterator<span style="color: #333333;">&amp;</span> lhs, <span style="color: #008800;">const</span> Iterator<span style="color: #333333;">&amp;</span> rhs);
        <span style="color: #008800;">friend</span> <span style="color: #333399;">bool</span> <span style="color: #008800;">operator</span> <span style="color: #333333;">!=</span>(<span style="color: #008800;">const</span> Iterator<span style="color: #333333;">&amp;</span> lhs, <span style="color: #008800;">const</span> Iterator<span style="color: #333333;">&amp;</span> rhs);
        <span style="color: #333399;">void</span> <span style="color: #0066bb;">print_Iterator</span>(){
            <span style="color: #008800;">if</span> (it){
                cout<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">"iterator: "</span>;
                print_array(it<span style="color: #333333;">-&gt;</span>data, it<span style="color: #333333;">-&gt;</span>data_count, key_ptr);
            }
            <span style="color: #008800;">else</span>{
                cout<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">"iterator: NULL, key_ptr: "</span><span style="color: #333333;">&lt;&lt;</span>key_ptr<span style="color: #333333;">&lt;&lt;</span>endl;
            }
        }
        <span style="color: #333399;">bool</span> <span style="color: #0066bb;">is_null</span>(){<span style="color: #008800;">return</span> <span style="color: #333333;">!</span>it;}
        <span style="color: #333399;">void</span> <span style="color: #0066bb;">info</span>(){
            cout<span style="color: #333333;">&lt;&lt;</span>endl<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">"Iterator info:"</span><span style="color: #333333;">&lt;&lt;</span>endl;
            cout<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">"key_ptr: "</span><span style="color: #333333;">&lt;&lt;</span>key_ptr<span style="color: #333333;">&lt;&lt;</span>endl;
            cout<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">"it: "</span><span style="color: #333333;">&lt;&lt;*</span>it<span style="color: #333333;">&lt;&lt;</span>endl;
        }

    <span style="color: #997700;">private:</span>
        BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;*</span> it;
        <span style="color: #333399;">int</span> key_ptr;
    };

    BPlusTree(<span style="color: #333399;">bool</span> dups <span style="color: #333333;">=</span> <span style="color: #007020;">false</span>);
    BPlusTree(T <span style="color: #333333;">*</span>a, <span style="color: #333399;">int</span> size, <span style="color: #333399;">bool</span> dups <span style="color: #333333;">=</span> <span style="color: #007020;">false</span>);

    <span style="color: #888888;">//big three:</span>
    BPlusTree(<span style="color: #008800;">const</span> BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> other);
    <span style="color: #333333;">~</span>BPlusTree();
    BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> <span style="color: #008800;">operator</span> <span style="color: #333333;">=</span>(<span style="color: #008800;">const</span> BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> RHS);

    <span style="color: #333399;">void</span> <span style="color: #0066bb;">copy_tree</span>(<span style="color: #008800;">const</span> BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> other);  <span style="color: #888888;">//copy other into this object</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">copy_tree</span>(<span style="color: #008800;">const</span> BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> other, BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;*&amp;</span> last_node);

    <span style="color: #333399;">void</span> <span style="color: #0066bb;">insert</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);   <span style="color: #888888;">//insert entry into the tree</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">remove</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);   <span style="color: #888888;">//remove entry from the tree</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">clear_tree</span>();             <span style="color: #888888;">//clear this object (delete all nodes etc.)</span>

    <span style="color: #333399;">bool</span> contains(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry) <span style="color: #008800;">const</span>; <span style="color: #888888;">//true if entry can be found</span>
    T<span style="color: #333333;">&amp;</span> get(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);              <span style="color: #888888;">//return a reference to entry</span>
    <span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> get(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry)<span style="color: #008800;">const</span>;   <span style="color: #888888;">//return a reference to entry</span>
    T<span style="color: #333333;">&amp;</span> get_existing(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);     <span style="color: #888888;">//return a reference to entry</span>
    Iterator <span style="color: #0066bb;">find</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> key);         <span style="color: #888888;">//return an iterator to this key.</span>
                                         <span style="color: #888888;">//     NULL if not there.</span>
    Iterator <span style="color: #0066bb;">lower_bound</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> key);  <span style="color: #888888;">//return first that goes NOT BEFORE</span>
                                         <span style="color: #888888;">// key entry or next if does not</span>
                                         <span style="color: #888888;">// exist: &gt;= entry</span>
    Iterator <span style="color: #0066bb;">upper_bound</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> key);  <span style="color: #888888;">//return first that goes AFTER key</span>
                                         <span style="color: #888888;">//exist or not, the next entry  &gt;entry</span>

    <span style="color: #333399;">int</span> size() <span style="color: #008800;">const</span>;                    <span style="color: #888888;">//count the number of elements</span>

    <span style="color: #333399;">bool</span> empty() <span style="color: #008800;">const</span>;                  <span style="color: #888888;">//true if the tree is empty</span>

    <span style="color: #333399;">void</span> print_tree(<span style="color: #333399;">int</span> level <span style="color: #333333;">=</span> <span style="color: #0000dd;">0</span>,
                    ostream <span style="color: #333333;">&amp;</span>outs<span style="color: #333333;">=</span>cout) <span style="color: #008800;">const</span>;
    <span style="color: #008800;">friend</span> ostream<span style="color: #333333;">&amp;</span> <span style="color: #008800;">operator</span><span style="color: #333333;">&lt;&lt;</span>(ostream<span style="color: #333333;">&amp;</span> outs,
                               <span style="color: #008800;">const</span> BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> print_me){
        print_me.print_tree(<span style="color: #0000dd;">0</span>, outs);
        <span style="color: #008800;">return</span> outs;
    }

    <span style="color: #333399;">bool</span> is_valid();
    string <span style="color: #0066bb;">in_order</span>();

    Iterator <span style="color: #0066bb;">begin</span>();
    Iterator <span style="color: #0066bb;">end</span>();
    ostream<span style="color: #333333;">&amp;</span> list_keys(Iterator from <span style="color: #333333;">=</span> <span style="color: #007020;">NULL</span>, Iterator to <span style="color: #333333;">=</span> <span style="color: #007020;">NULL</span>){
        <span style="color: #008800;">if</span> (from <span style="color: #333333;">==</span> <span style="color: #007020;">NULL</span>) from <span style="color: #333333;">=</span> begin();
        <span style="color: #008800;">if</span> (to <span style="color: #333333;">==</span> <span style="color: #007020;">NULL</span>) to <span style="color: #333333;">=</span> end();
        <span style="color: #008800;">for</span> (Iterator it <span style="color: #333333;">=</span> from; it <span style="color: #333333;">!=</span> to; it<span style="color: #333333;">++</span>)
            cout<span style="color: #333333;">&lt;&lt;*</span>it<span style="color: #333333;">&lt;&lt;</span><span style="background-color: #fff0f0;">" "</span>;
        <span style="color: #008800;">return</span> cout;

    }

<span style="color: #997700;">private:</span>
    <span style="color: #008800;">static</span> <span style="color: #008800;">const</span> <span style="color: #333399;">int</span> MINIMUM <span style="color: #333333;">=</span> <span style="color: #0000dd;">1</span>;
    <span style="color: #008800;">static</span> <span style="color: #008800;">const</span> <span style="color: #333399;">int</span> MAXIMUM <span style="color: #333333;">=</span> <span style="color: #0000dd;">2</span> <span style="color: #333333;">*</span> MINIMUM;

    <span style="color: #333399;">bool</span> dups_ok;                        <span style="color: #888888;">//true if duplicate keys are allowed</span>
    <span style="color: #333399;">int</span> data_count;                      <span style="color: #888888;">//number of data elements</span>
    T data[MAXIMUM <span style="color: #333333;">+</span> <span style="color: #0000dd;">1</span>];                 <span style="color: #888888;">//holds the keys</span>
    <span style="color: #333399;">int</span> child_count;                     <span style="color: #888888;">//number of children</span>
    BPlusTree<span style="color: #333333;">*</span> subset[MAXIMUM <span style="color: #333333;">+</span> <span style="color: #0000dd;">2</span>];      <span style="color: #888888;">//subtrees</span>
    BPlusTree<span style="color: #333333;">*</span> next;
    <span style="color: #333399;">bool</span> is_leaf() <span style="color: #008800;">const</span>
    {<span style="color: #008800;">return</span> child_count<span style="color: #333333;">==</span><span style="color: #0000dd;">0</span>;}             <span style="color: #888888;">//true if this is a leaf node</span>

    T<span style="color: #333333;">*</span> find_ptr(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);         <span style="color: #888888;">//return a pointer to this key.</span>
                                         <span style="color: #888888;">// NULL if not there.</span>

    <span style="color: #888888;">//insert element functions</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">loose_insert</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);   <span style="color: #888888;">//allows MAXIMUM+1 data elements in</span>
                                         <span style="color: #888888;">//   the root</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">fix_excess</span>(<span style="color: #333399;">int</span> i);              <span style="color: #888888;">//fix excess in child i</span>

    <span style="color: #888888;">//remove element functions:</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">loose_remove</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);  <span style="color: #888888;">//allows MINIMUM-1 data elements</span>
                                        <span style="color: #888888;">//  in the root</span>

    BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;*</span> fix_shortage(<span style="color: #333399;">int</span> i);  <span style="color: #888888;">//fix shortage in child i</span>
    <span style="color: #888888;">// and return the smallest key in this subtree</span>
    BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;*</span> get_smallest_node();
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">get_smallest</span>(T<span style="color: #333333;">&amp;</span> entry);      <span style="color: #888888;">//entry := leftmost leaf</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">get_biggest</span>(T<span style="color: #333333;">&amp;</span> entry);       <span style="color: #888888;">//entry := rightmost leaf</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">remove_biggest</span>(T<span style="color: #333333;">&amp;</span> entry);    <span style="color: #888888;">//remove the biggest child of tree-&gt;entry</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">transfer_left</span>(<span style="color: #333399;">int</span> i);        <span style="color: #888888;">//transfer one element LEFT from child i</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">transfer_right</span>(<span style="color: #333399;">int</span> i);       <span style="color: #888888;">//transfer one element RIGHT from child i</span>
    BPlusTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;</span> <span style="color: #333333;">*</span>merge_with_next_subset(<span style="color: #333399;">int</span> i); <span style="color: #888888;">//merge subset i with  i+1</span>

};
</pre>
</div>
<h3><strong>BPlusTree Member Functions:</strong></h3>
<p><strong>CTOR/ BIG THREE,&nbsp;</strong></p>
<pre><span class="comment">//---------------------------------------------------------------------
//            C T O R  /  B I G   T H R E E
//---------------------------------------------------------------------
</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>BPlusTree<span class="operator">(</span><span class="type">bool</span> dups<span class="operator">):</span>dups_ok<span class="operator">(</span>dups<span class="operator">),</span> data_count<span class="operator">(</span><span class="int">0</span><span class="operator">),</span>
                                   child_count<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> next<span class="operator">(</span>NULL<span class="operator">){</span><span class="comment">
    //left emtpy
</span><span class="operator">}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>BPlusTree<span class="operator">(</span><span class="keyword">const</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;&amp;</span> other<span class="operator">):</span>
                        data_count<span class="operator">(</span><span class="int">0</span><span class="operator">),</span> child_count<span class="operator">(</span><span class="int">0</span><span class="operator">){
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::~</span>BPlusTree<span class="operator">(){</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="flow">
    if</span><span class="operator"> (</span>debug<span class="operator">)</span> cout<span class="operator">&lt;&lt;</span><span class="string">"** destructor fired!"</span><span class="operator">&lt;&lt;</span>endl<span class="operator">;
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;&amp;</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span><span class="keyword">operator</span><span class="operator"> =(</span><span class="keyword">const</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;&amp;</span> RHS<span class="operator">){</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="flow">
    if</span><span class="operator"> (</span>debug<span class="operator">)</span> cout<span class="operator">&lt;&lt;</span><span class="string">"** assignment operator fired!"</span><span class="operator">&lt;&lt;</span>endl<span class="operator">;
}</span></pre>
<p><strong>BEGIN / END:</strong></p>
<pre><span class="comment">//---------------------------------------------------------------------
//            B E G I N ( )   &amp;   E N D ( )
//---------------------------------------------------------------------
</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="keyword">
typename</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>Iterator BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>begin<span class="operator">(){</span><span class="flow">
    return</span> Iterator<span class="operator">(</span>get_smallest_node<span class="operator">());
}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="keyword">
typename</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>Iterator BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>end<span class="operator">(){</span><span class="flow">
    return</span> Iterator<span class="operator">(</span>NULL<span class="operator">);
}</span>

</pre>
<p><strong>CONTAINS / GET / FIND:</strong></p>
<pre><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
T<span class="operator">&amp;</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>get<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">) {</span><span class="comment">
    //If entry is not in the tree, add it to the tree
    //assert(contains(entry));
</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="flow">
    if</span><span class="operator"> (!</span>contains<span class="operator">(</span>entry<span class="operator">))</span>
        insert<span class="operator">(</span>entry<span class="operator">);</span><span class="flow">

    return</span> get_existing<span class="operator">(</span>entry<span class="operator">);
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
T<span class="operator">&amp;</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>get_existing<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">) {</span><span class="comment">
    /*
 * ---------------------------------------------------------------
 * This routing explains plainly how the BPlusTree is organized.
 * i = first_ge
 *       |      found         |    !found         |
 * ------|--------------------|-------------------|
 * leaf  |  you're done       | it's not there    |
 *       |                    |                   |
 * ------|--------------------|-------------------|
 * !leaf | subset[i+1]-&gt;get() |  subset[i]-&gt;get() |
 *       | (inner node)       |                   |
 * ------|--------------------|-------------------|
 *       |                    |                   |
 *
 * ---------------------------------------------------------------
 *
 */</span><span class="comment">
    //assert that entry is not in the tree.
    //assert(contains(entry));
</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="type">
    int</span> i<span class="operator"> =</span> first_ge<span class="operator">(</span>data<span class="operator">,</span> data_count<span class="operator">,</span> entry<span class="operator">);</span><span class="type">
    bool</span> found<span class="operator"> = (</span>i<span class="operator">&lt;</span>data_count<span class="operator"> &amp;&amp;</span> data<span class="operator">[</span>i<span class="operator">]==</span>entry<span class="operator">);</span><span class="flow">
    if</span><span class="operator"> (</span>is_leaf<span class="operator">())</span><span class="flow">
        if</span><span class="operator"> (</span>found<span class="operator">){</span><span class="flow">
            return</span> data<span class="operator">[</span>i<span class="operator">];
        }</span><span class="flow">
        else</span><span class="operator">{</span><span class="flow">
            if</span><span class="operator"> (</span>debug<span class="operator">)</span> cout<span class="operator">&lt;&lt;</span><span class="string">"get_existing was called with nonexistent entry"</span><span class="operator">&lt;&lt;</span>endl<span class="operator">;</span>
            assert<span class="operator">(</span>found<span class="operator">);
        }</span><span class="flow">
    if</span><span class="operator"> (</span>found<span class="operator">)</span><span class="comment"> //inner node
</span><span class="flow">        return</span> subset<span class="operator">[</span>i<span class="operator">+</span><span class="int">1</span><span class="operator">]-&gt;</span>get<span class="operator">(</span>entry<span class="operator">);</span><span class="comment">
        //or just return true?
</span><span class="flow">    else</span><span class="comment"> //not found yet...
</span><span class="flow">        return</span> subset<span class="operator">[</span>i<span class="operator">]-&gt;</span>get<span class="operator">(</span>entry<span class="operator">);


}</span>
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>VALIDATION:</strong></p>
<p>Everytime you return false, make sure you generate a meaningful message to help you with debugging. What exactly is wrong. What are the values. Which item violated the B+Tree rules</p>
<pre><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
bool</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>is_valid<span class="operator">(){</span><span class="comment">
    
    //should check that every data[i] &lt; data[i+1]
</span><span class="flow">    if</span><span class="operator"> (</span>is_leaf<span class="operator">())</span><span class="flow">
        return</span><span class="bool"> true</span><span class="operator">;</span><span class="comment">
    

    //data[data_count-1] must be less than equal to 
    //  every subset[child_count-1]-&gt;data[ ]
    
    //every data[i] is greater than every subset[i]-&gt;data[ ]
    
    //B+Tree: Every data[i] is equal to subset[i+1]-&gt;smallest
    
    //Recursively validate every subset[i]
</span><span class="flow">
    return</span><span class="bool"> true</span><span class="operator">;
}</span></pre>
<p>&nbsp;</p>
<p><strong>REMOVE:</strong></p>
<pre><span class="comment">//------------------------------------------------
//          R E M O V E
//------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>remove<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    /*
     * ---------------------------------------------------------------------------------
     * Same as BTree:
     * Loose_remove the entry from this tree.
     * Shrink if you have to
     * ---------------------------------------------------------------------------------
     * once you return from loose_remove, the root (this object) may have no data and
     * only a single subset:
     * now, the tree must shrink:
     *
     * point a temporary pointer (shrink_ptr) and point it to this root's only subset
     * copy all the data and subsets of this subset into the root (through shrink_ptr)
     * now, the root contains all the data and poiners of it's old child.
     * now, simply delete shrink_ptr, and the tree has shrunk by one level.
     * Note, the root node of the tree will always be the same, it's the
     * child node we delete
     *
     *
     */</span><span class="operator">

}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>loose_remove<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
     /* four cases:
           leaves:
                a. not found: there is nothing to do
                b. found    : just remove the target
           non leaf:
                c. not found: subset[i]-&gt;loose_remove, fix_shortage(i)
                d. found    : subset[i+1]-&gt;loose_remove, fix_shortage(i+1) [...]
                    (No More remove_biggest)

             |   !found               |   found                 |
       ------|------------------------|-------------------------|-------
       leaf  |  a: nothing            | b: delete               |
             |     to do              |    target               |
       ------|------------------------|-------------------------|-------
       !leaf | c:                     | d: B_PLUS_TREE          |
             |  [i]-&gt;  loose_remove   |   [i+1]-&gt; loose_remove  |
             |  fix_shortage(i)       | fix_shortage(i+1) [...] |
       ------|------------------------|-------------------------|-------


     */</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span>
    T found_entry<span class="operator">;</span><span class="flow">
    if</span><span class="operator"> (</span>is_leaf<span class="operator">()){</span><span class="flow">
        if</span><span class="operator">(!</span>found<span class="operator">){</span><span class="comment">
            //[a.] nothing to do
            //entry not in this tree
</span><span class="operator">        }</span><span class="flow">
        else</span><span class="operator">{</span><span class="comment">
            //[b.] just delete the item
            //   my parent will take care of my shortage
</span><span class="operator">        }

    }</span><span class="flow">
    else</span><span class="operator">{</span><span class="comment">
        //not leaf:
        // ---- 000 B_PLUS_TREE: no more remove_biggest
</span><span class="flow">        if</span><span class="operator"> (!</span>found<span class="operator">){</span><span class="comment">
            //[c.] Not here: subset[i]-&gt;loose_remove
            //not found yet. search in the next level:
</span><span class="operator">        }</span><span class="flow">
        else</span><span class="operator">{</span><span class="comment">
            //[d.] found key in an inner node:subset[i+1]-&gt;loose_remove
</span>            assert<span class="operator">(</span>i<span class="operator"> &lt;</span> child_count<span class="operator">-</span><span class="int">1</span><span class="operator">);</span><span class="comment">

            /*
             * Here's The Story:
             * data[i] is the same as the item that we have deleted.
             * so, now, it needs to be replaced by the current smallest key
             *      in subset[i+1]
             * Problem: After fix_shortage, data[i] <sub>could have moved to a different index(?)</sub>
             *      or it could have sunk down to a lower level as a result of merge
             *      we need to find this item and replace it.
             *
             *      Before fix_shortage: we cannot replace data[i] with subset[i+1]-&gt;smallest
             *      before fix_excess because this smallest key could be the very entry
             *      we are removing. So, we'd be replacing data[i] with entry. and this will
             *      leave the deleted key in the inner nodes.
             *
             *      After fix_shortage: We have no way of knowing where data[i] key (which is
             *      same as entry) will end up. It could move down one level by the time
             *      fix_shortage returns.
             *
             *      Therefore it seems like we have no choice but to search for it in
             *      data[ ] AND subset[i]-&gt;data[ ]
             * Current Solution: Kind of messy:
             *      After fix_shortage(i+1):
             *      Search for entry in data[ ] and if found, replace it with smallest.
             *      otherwise, search for it in subset[i]-&gt;data[ ]
             *          and replace it. that's where the key (entry) will end up after
             *          fix order returns (credit: Jiaruy Li)
             *
             */</span>
            subset<span class="operator">[</span>i<span class="operator">+</span><span class="int">1</span><span class="operator">]-&gt;</span>loose_remove<span class="operator">(</span>entry<span class="operator">);</span><span class="comment">

            //remember. it's possible that data[i] will be gone by the time
            //      fix_shortage returns.
            //key was removed from subset[i+1]:
            //  1. shortage: find entry in data or subset[i+1]-&gt;data 
            //              and replace it with subset[i+1]-&gt;smallest
            //  2. no shortage: replace data[i] with subset[i+1]-&gt;smallest
</span><span class="operator">        }</span><span class="comment">
        // --------------------------------------------------------
</span><span class="operator">    }
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;*</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fix_shortage<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * fix shortage in subtree i:
     * if child i+1 has more than MINIMUM,
     *          (borrow from right) transfer / rotate left(i+1)
     * elif child i-1 has more than MINIMUM,
     *          (borrow from left) transfer /rotate right(i-1)
     * elif there is a left sibling,
     *          merge with prev child: merge(i-1)
     * else
     *          merge with next (right) child: merge(i)
     *
     *
     * returns a pointer to the fixed_subset
     */</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="flow">
    if</span><span class="operator"> ((</span>i<span class="operator">&lt;</span>child_count<span class="operator">-</span><span class="int">1</span><span class="operator">) &amp;&amp; (</span>subset<span class="operator">[</span>i<span class="operator">+</span><span class="int">1</span><span class="operator">]-&gt;</span>data_count<span class="operator"> &gt;</span> MINIMUM<span class="operator">)){</span><span class="comment">
        //borrow from right subtree if you can
</span>
        transfer_left<span class="operator">(</span>i<span class="operator">+</span><span class="int">1</span><span class="operator">);</span><span class="flow">
        return</span> subset<span class="operator">[</span>i<span class="operator">];
    }</span><span class="comment">
    //...
</span><span class="operator">}</span><span class="keyword">


template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>get_smallest<span class="operator">(</span>T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    //replace entry with the left_most leaf of this tree
    // Keep looking in the first subtree (recursive)
    //  until you get to a leaf.
    // Then, replace entry with data[0] of the leaf node
</span><span class="keyword">    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;*</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>merge_with_next_subset<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * ----------------------------------------------------------------------
     *  Merge subset[i] with subset [i+1] REMOVE data[i];
     *  non leaf: same as BTree
     *  leaves  : delete but do not bring down data[i]
     * ----------------------------------------------------------------------
     *
     *   1. remove data[i] from this object
     *   2. if not a leaf, append it to child[i]-&gt;data:
     *   3. Move all data items from subset[i+1]-&gt;data to right of subset[i]-&gt;data
     *   4. Move all subset pointers from subset[i+1]-&gt;subset to
     *          right of subset[i]-&gt;subset
     *   5. delete subset[i+1] (store in a temp ptr)
     *   6. if a leaf, point subset[i]-&gt;next to temp_ptr-&gt;next
     *   6. delete temp ptr
     *
     *
     * non-leaf nodes: (same as BTree)
     * ------------------
     *  i = 0:
     *             [50  100]
     *          /      |     \
     *  [  ]         [75]       ....
     *    |         /    \
     *   [a]      [b]    [c]
     *
     *  bring down data[i], merge it with subset[i] and subset[i+1]:
     *      then, get rid of subset[i+1]
     *             [100]
     *               |
     *            [50|75]       ....
     *            /  |  \
     *         [a]  [b]  [c]
     *
     *
     *
     * leaf node:
     * ----------------
     * Exactly the same, but do not attach the deleted data[i] to subset[i]-&gt;data[ ]
     *
     *  i = 0 : merge 5 and [()]
     *        [7 | 10]
     *      /    |     \
     *  [5]-&gt;   [()]-&gt;  [10]
     *
     *  Delete data[i] (7), merge subset[i] and subset[i+1]
     *      WITHOUT bringing down data[i]
     *
     *        [10]
     *      /      \
     *  [5]-&gt;      [10]
     *
     *
     * i = 1 merge 7 and [()]
     *        [7 | 10]
     *      /    |     \
     *  [5]-&gt;   [7]-&gt;  [()]
     *
     *  Delete data[i] (10), merge subset[i] and subset[i+1]
     *      WITHOUT bringing down data[i]
     *
     *        [7]
     *      /     \
     *  [5]-&gt;      [7]
     *
     *
     *
     *
     */</span><span class="keyword">
    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;</span><span class="comment">
    //...
</span><span class="flow">
    return</span> subset<span class="operator">[</span>i<span class="operator">];

}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>transfer_left<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * --------------------------------------------------------------
     * transfer_left: from subset[i] to subset[i-1]
     *      non-leaf: same as BTree
     *      leaves  : rotate and leave and update data[i-1] with subset[i]-&gt;data[0]
     *                  leftmost key after you borrowed goes to replace data[i-1]
     * --------------------------------------------------------------
     *
     * non-leaf keys: BTree's rotate_left
     * ---------------
     *
     * (0 &lt; i &lt; child_count) and (subset[i]-&gt;data_count &gt; MINIMUM)
     * subset[i-1] has only MINIMUM - 1 entries.
     *
     * item transfers from child[i] to child [i-1]
     *
     * FIRST item of subset[i]-&gt;data moves up to data to replace data[i-1],
     * data[i-1] moves down to the RIGHT of subset[i-1]-&gt;data
     *
     *  i = 1:
     *              [50  100]
     *  [  ]         [65 75]       ....
     *   [a]      [b]  [c]  [d]
     *
     *  65 move up to replace 50 (data[i])
     *  65's child (its child 0) moves over to be the future child of 50
     *  50 moves down to the right of subset[i]-&gt;data
     *
     *               [65 100]
     *   [50]         [ 75 ]       ....
     * [a]  [b]      [c]  [d]
     *
     * ****This does not belong here:
     * last item of subset[i-1]-&gt;data moves up to data to replace data[i],
     * data[i] moves down to the RIGHT of subset[i]-&gt;data
     *
     * leaf keys:
     * -------------
     *  fix_shortage(0) calls trnasfer_left(1) so, i = 1
     *          [7 | 10]
     *        /    |     \
     * [( )]&lt;=[(7) | 8]  [10]
     *
     * 1. transfer subset[i(1)]-&gt;data[0] to end of subset[i-1]
     *        [7 | 10]
     *      /    |     \
     *   [7]    [8]   [10]
     *
     * 2. update parent of the transfered subset: data[i-1 (0)] = subset[i(1)]-&gt;data[0]
     *
     *        [(8) | 10]
     *      /      |     \
     *   [7]     [(8)]   [10]
     *
     *
     *
     */</span><span class="operator">
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>transfer_right<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * --------------------------------------------------------------
     * transfer right from subset[i] to subset[i+1]
     *      non-leaf: same as BTree
     *      leaves  : rotate and leave a 'trace':
     *              data[i] is replaced with subset[i+1]-&gt;data[0]
     *              after you borrowed the key,
     * --------------------------------------------------------------
     *
     * non-leaf keys: BTree's rotate_right
     * ---------------
     * (i &lt; child_count - 1) and (subset[i-1]-&gt;data_count &gt; MINIMUM)
     * subset[i+ 1] has only MINIMUM - 1 entries.
     *
     * item transfers from child[i] to child [i+1]
     *
     * LAST item of subset[i]-&gt;data moves up to data to replace data[i],
     * data[i] moves down to the LEFT of subset[i+1]-&gt;data
     *
     * i = 1
     *                     [50 100]
     *      [20 30]        [65 75]          [ ]
     *  [..] [..] [..]   [a] [b] [c]        [..]
     *
     *  75 moves up to replace 100 (data[i])
     *  75's child (its last child) moves over to be the (child 0) child of 100
     *  100 moves down to subset[i]-&gt;data
     *
     *                     [50 75]
     *      [20 30]          [65]          [100]
     *  [..] [..] [..]     [a] [b]        [c] [..]
     *
     * last item of subset[i-1]-&gt;data moves up to data,
     * data[i] moves down to the RIGHT of subset[i]-&gt;data
     *
     * leaf keys:
     * -------------
     *  fix_shortage(2) calls trnasfer_right(1) so, i = 1 subset[i] is ([7|8])
     *  subset[i+1] is the one being fixed.
     *        [7 | 10]
     *      /    |     \
     * [5|6]-&gt;[7 | (8)]=&gt;[()]
     *
     * 1. transfer subset[i(1)]-&gt;data[last item] to left of subset[i+1]-&gt;data
     *        [7 | (10)]
     *      /    |     \
     *   [5|6]-&gt;[7]-&gt; [8]
     *
     * 2. update parent of the transfered subset: data[i (1)] = subset[i+1(2)]-&gt;data[0]
     *
     *        [7 | 8]
     *      /    |    \
     *   [5|6]-&gt;[7]-&gt; [8]
     *
     *
     */</span><span class="keyword">

    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;

}</span>
</pre>
<p>&nbsp;</p>
<p><strong>INSERT:</strong></p>
<pre><span class="comment">//------------------------------------------------
//          I N S E R T
//------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>insert<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    //in order for this class to be able to keep track of the number of the keys,
    //      this function (and the functions it calls ) must return a success code.
    //If we are to keep track of the number the keys (as opposed to key/values)
    //  then the success code must distinguish between inserting a new key, or
    //  adding a new key to the existing key. (for "dupes_ok")
    //
    //loose_insert this entry into this root.
    //loose_insert(entry) will insert entry into this tree. Once it returns,
    //  all the subtrees are valid
    //  btree subtrees EXCEPT this root may have one extra data item:
    //    in this case (we have excess in the root)
    //      create a new node, copy all the contents of this root into it,
    //      clear this root node,
    //      make the new node this root's only child (subset[0])
    //
    //Then, call fix_excess on this only subset (subset[0])
</span><span class="operator">}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>loose_insert<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    /*
       int i = first_ge(data, data_count, entry);
       bool found = (i&lt;data_count &amp;&amp; data[i] == entry);

       three cases:
         found
         a. found/leaf: deal with duplicates: call +
         b. found/no leaf: subset[i+1]-&gt;loose_insert(entry)
                           fix_excess(i+1) if there is a need

         ! found:
         c. !found / leaf : insert entry in data at position i
         c. !found / !leaf: subset[i]-&gt;loose_insert(entry)
                            fix_excess(i) if there is a need

            |   found          |   !found         |
      ------|------------------|------------------|-------
      leaf  |a. dups? +        | c: insert entry  |
            |                  |    at data[i]    |
      ------|------------------|------------------|-------
            | b.               | d.               |
            |subset[i+1]-&gt;     | subset[i]-&gt;      |
      !leaf | loose_insert()   |  loose_insert()  |
            |fix_excess(i+1)   | fix_excess(i)    |
            |                  |                  |
      ------|------------------|------------------|-------
    */</span><span class="keyword">

    const</span><span class="type"> bool</span> debug<span class="operator"> =</span><span class="bool"> false</span><span class="operator">;
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fix_excess<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    //this node's child i has one too many items: 3 steps:
    //1. add a new subset at location i+1 of this node
    //2. split subset[i] (both the subset array and the data array) and move half into
    //      subset[i+1] (this is the subset we created in step 1.)
    //3. detach the last data item of subset[i] and bring it and insert
    //      it into this node's data[]
    //
    //Note that this last step may cause this node to have too many itesm.
    //  This is OK. This will be
    //  dealt with at the higher recursive level. (my parent will fix it!)
    //
    //NOTE: ODD/EVENNESS
    // when there is an excess, data_count will always be odd
    //  and child_count will always be even.
    //  so, splitting is always the same.

    //  000 B_PLUS_TREE
    //  if (subset[i]-&gt;is_leaf())
    //  transfer the middle entry to the right and...
    //  Deal with next pointers. just like linked list insert
</span><span class="operator">

}</span></pre>
<p><strong>SIZE / EMPTY:</strong></p>
<pre><span class="comment">//---------------------------------------------------------------
//      S I Z E  /  E M P T Y
//---------------------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
int</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>size<span class="operator">()</span><span class="keyword"> const</span><span class="operator">{</span><span class="comment">
    //this function counts the number of keys in the btree
</span><span class="operator">}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
bool</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>empty<span class="operator">()</span><span class="keyword"> const</span><span class="operator">{</span><span class="flow">
    return</span><span class="operator"> (</span>data_count<span class="operator"> ==</span><span class="int">0</span><span class="operator">);
}</span>
</pre>
<p><strong>CLEAR / COPY:</strong></p>
<pre><span class="comment">//---------------------------------------------------------------
//      C L E A R   /  C O P Y
//---------------------------------------------------------------
</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>clear_tree<span class="operator">(){
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>copy_tree<span class="operator">(</span><span class="keyword">const</span> BPlusTree<span class="operator">&lt;</span>T<span class="operator">&gt;&amp;</span> other<span class="operator">){</span><span class="comment">
    //assumes this btree is empty. [memory leaks otherwise]
</span>    assert<span class="operator">(</span>empty<span class="operator">());
}</span>
</pre>
<p><strong>PRINT:</strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h3><strong>TESTING:</strong></h3>
<p>Please see&nbsp;&nbsp;<a title="BTree / B+Tree main.cpp" href="11-80-bt-btree-slash-b+tree-main-dot-cpp.html" data-api-returntype="Assignment">BTree / B+Tree main.cpp</a></p>
<h3><strong>BPlusTree ARRAY FUNCTIONS:</strong></h3>
<p>&nbsp;Please see&nbsp;<a title="BTree / B+Tree Array Functions" href="11-80-bt-btree-slash-b+tree-array-functions.html" data-api-returntype="Assignment">BTree / B+Tree Array Functions</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>