<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Assignment: 11_80_btree</title>
</head>
<body>
<h2 style="text-align: center;"><strong>B T R E E&nbsp; &nbsp; C L A S S</strong></h2>
<p><strong> <img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.dropbox.com/s/ptqw70ajx0qvnok/Screenshot%202017-10-22%2013.30.10.png?dl=1" alt="" loading="lazy"> </strong></p>
<p><strong>BTree class</strong> functions are heavily dependant on the utility array functions to do the low level moving of data and subtrees.</p>
<p>&nbsp;</p>
<div style="background: #ffffff; overflow: auto; width: auto; border: solid gray; border-width: .1em .1em .1em .8em; padding: .2em .6em;">
<pre style="margin: 0; line-height: 125%;"><span style="color: #008800;">template</span> <span style="color: #333333;">&lt;</span><span style="color: #008800;">class</span> <span style="color: #bb0066;">T</span><span style="color: #333333;">&gt;</span>
<span style="color: #008800;">class</span> <span style="color: #bb0066;">BTree</span>
{
<span style="color: #997700;">public:</span>
    BTree(<span style="color: #333399;">bool</span> dups <span style="color: #333333;">=</span> <span style="color: #007020;">false</span>);
    BTree(T <span style="color: #333333;">*</span>a, <span style="color: #333399;">int</span> size, <span style="color: #333399;">bool</span> dups <span style="color: #333333;">=</span> <span style="color: #007020;">false</span>);
    <span style="color: #888888;">//big three:</span>
    BTree(<span style="color: #008800;">const</span> BTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> other);
    <span style="color: #333333;">~</span>BTree();
    BTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> <span style="color: #008800;">operator</span> <span style="color: #333333;">=</span>(<span style="color: #008800;">const</span> BTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> RHS);

    <span style="color: #333399;">void</span> <span style="color: #0066bb;">insert</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);                <span style="color: #888888;">//insert entry into the tree</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">remove</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);                <span style="color: #888888;">//remove entry from the tree</span>

    <span style="color: #333399;">void</span> <span style="color: #0066bb;">clear_tree</span>();                          <span style="color: #888888;">//clear this object</span>
                                                <span style="color: #888888;">//  (delete all nodes etc.)</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">copy_tree</span>(<span style="color: #008800;">const</span> BTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> other);      <span style="color: #888888;">//copy other into this object</span>

    <span style="color: #333399;">bool</span> <span style="color: #0066bb;">contains</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);              <span style="color: #888888;">//true if entry can be found in</span>
                                                <span style="color: #888888;">//                  the array</span>
    T<span style="color: #333333;">&amp;</span> get(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);                     <span style="color: #888888;">//return a reference to entry</span>
                                                <span style="color: #888888;">//                  in the tree</span>
    T<span style="color: #333333;">*</span> <span style="color: #0066bb;">find</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);                    <span style="color: #888888;">//return a pointer to this key.</span>
                                                <span style="color: #888888;">//          NULL if not there.</span>

    <span style="color: #333399;">int</span> size() <span style="color: #008800;">const</span>;                           <span style="color: #888888;">//count the number of elements</span>
                                                <span style="color: #888888;">//              in the tree</span>
    <span style="color: #333399;">bool</span> empty() <span style="color: #008800;">const</span>;                         <span style="color: #888888;">//true if the tree is empty</span>

    <span style="color: #333399;">bool</span> <span style="color: #0066bb;">is_valid</span>(){<span style="color: #008800;">return</span> <span style="color: #007020;">true</span>;}
                                                <span style="color: #888888;">//print a readable version of</span>
                                                <span style="color: #888888;">//                  the tree</span>
    <span style="color: #333399;">void</span> print_tree(<span style="color: #333399;">int</span> level <span style="color: #333333;">=</span> <span style="color: #0000dd;">0</span>, ostream <span style="color: #333333;">&amp;</span>outs<span style="color: #333333;">=</span>cout) <span style="color: #008800;">const</span>;
    <span style="color: #008800;">friend</span> ostream<span style="color: #333333;">&amp;</span> <span style="color: #008800;">operator</span><span style="color: #333333;">&lt;&lt;</span>(ostream<span style="color: #333333;">&amp;</span> outs, <span style="color: #008800;">const</span> BTree<span style="color: #333333;">&lt;</span>T<span style="color: #333333;">&gt;&amp;</span> print_me){
        print_me.print_tree(<span style="color: #0000dd;">0</span>, outs);
        <span style="color: #008800;">return</span> outs;
    }

    string in_order();                          <span style="color: #888888;">// traverse the tree in an</span>
                                                <span style="color: #888888;">// inorder fashion, return a </span>
                                                <span style="color: #888888;">// string of all the data items</span>
                                                <span style="color: #888888;">// with vertical delimiters</span>

<span style="color: #997700;">private:</span>
    <span style="color: #008800;">static</span> <span style="color: #008800;">const</span> <span style="color: #333399;">int</span> MINIMUM <span style="color: #333333;">=</span> <span style="color: #0000dd;">1</span>;
    <span style="color: #008800;">static</span> <span style="color: #008800;">const</span> <span style="color: #333399;">int</span> MAXIMUM <span style="color: #333333;">=</span> <span style="color: #0000dd;">2</span> <span style="color: #333333;">*</span> MINIMUM;

    <span style="color: #333399;">bool</span> dups_ok;                               <span style="color: #888888;">//true if duplicate keys may be</span>
                                                <span style="color: #888888;">//      inserted</span>
    <span style="color: #333399;">int</span> data_count;                             <span style="color: #888888;">//number of data elements</span>
    T data[MAXIMUM <span style="color: #333333;">+</span> <span style="color: #0000dd;">1</span>];                        <span style="color: #888888;">//holds the keys</span>
    <span style="color: #333399;">int</span> child_count;                            <span style="color: #888888;">//number of children</span>
    BTree<span style="color: #333333;">*</span> subset[MAXIMUM <span style="color: #333333;">+</span> <span style="color: #0000dd;">2</span>];                 <span style="color: #888888;">//subtrees</span>

    <span style="color: #333399;">bool</span> is_leaf() <span style="color: #008800;">const</span> {<span style="color: #008800;">return</span> child_count<span style="color: #333333;">==</span><span style="color: #0000dd;">0</span>;} <span style="color: #888888;">//true if this is a leaf node</span>

    <span style="color: #888888;">//insert element functions</span>
    <span style="color: #333399;">void</span> loose_insert(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);          <span style="color: #888888;">//allows MAXIMUM+1 data</span>
                                                <span style="color: #888888;">//      elements in the root</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">fix_excess</span>(<span style="color: #333399;">int</span> i);                     <span style="color: #888888;">//fix excess of data elements</span>
                                                <span style="color: #888888;">//                  in child i</span>

    <span style="color: #888888;">//remove element functions:</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">loose_remove</span>(<span style="color: #008800;">const</span> T<span style="color: #333333;">&amp;</span> entry);          <span style="color: #888888;">//allows MINIMUM-1 data</span>
                                                <span style="color: #888888;">//      elements in the root</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">fix_shortage</span>(<span style="color: #333399;">int</span> i);                   <span style="color: #888888;">//fix shortage of data elements</span>
                                                <span style="color: #888888;">//                  in child i</span>

    <span style="color: #333399;">void</span> <span style="color: #0066bb;">remove_biggest</span>(T<span style="color: #333333;">&amp;</span> entry);              <span style="color: #888888;">//remove the biggest child of</span>
                                                <span style="color: #888888;">//          this tree-&gt;entry</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">rotate_left</span>(<span style="color: #333399;">int</span> i);                    <span style="color: #888888;">//transfer one element LEFT</span>
                                                <span style="color: #888888;">//              from child i</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">rotate_right</span>(<span style="color: #333399;">int</span> i);                   <span style="color: #888888;">//transfer one element RIGHT</span>
                                                <span style="color: #888888;">//              from child i</span>
    <span style="color: #333399;">void</span> <span style="color: #0066bb;">merge_with_next_subset</span>(<span style="color: #333399;">int</span> i);         <span style="color: #888888;">//merge subset i with subset</span>
                                                <span style="color: #888888;">//                      i+1</span>

};
</pre>
</div>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<pre></pre>
<p>Implement your <strong>print</strong> function as soon as possible:</p>
<pre><span class="comment">//---------------------------------------------------------------
//      P R I N T  E T C.
//---------------------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>print_tree<span class="operator">(</span><span class="type">int</span> level<span class="operator">,</span> ostream<span class="operator">&amp;</span> outs<span class="operator">)</span><span class="keyword"> const</span><span class="operator">{</span><span class="comment">
    //1. print the last child (if any)
    //2. print all the rest of the data and children
</span><span class="operator">
}</span></pre>
<p>Here is the summary of <strong>insert, remove</strong> and related member functions:</p>
<p>&nbsp;</p>
<pre><span class="comment">//------------------------------------------------
//          I N S E R T
//------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>insert<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    //in order for this class to be able to keep track of the number of the keys, this function (and the functions
    //  it calls ) must return a success code.
    //If we are to keep track of the number the keys (as opposed to key/values) then the success 
    //  code must distinguish between inserting a new key, or adding a new key to the existing key. 
    //  (for "dupes_ok")
    //
    //loose_insert this entry into this root.
    //loose_insert(entry) will insert entry into this tree. Once it returns, all the subtrees are valid
    //  btree subtrees EXCEPT this root may have one extra data item:
    //    in this case (we have excess in the root)
    //      create a new node, copy all the contents of this root into it,
    //      clear this root node,
    //      make the new node this root's only child (subset[0])
    //
    //Then, call fix_excess on this only subset (subset[0])
</span><span class="operator">}</span>

</pre>
<pre><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>loose_insert<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    /* 
       int i = first_ge(data, data_count, entry);
       bool found = (i&lt;data_count &amp;&amp; data[i] == entry);

       three cases:
         a. found: deal with duplicates
         ! found:
         b. leaf : insert entry in data at position i 
         c. !leaf: subset[i]-&gt;loose_insert(entry)
                   fix_excess(i) if there is a need    
            |   found     |   !found        |
      ------|-------------|-----------------|-------
      leaf  |  a. Deal    | b: insert entry |
            |     with    |    at data[i]   |
      ------|  duplicates |-----------------|-------
            |             | d: subset[i]-&gt;  |
      !leaf |             |    loose_insert |
            |             |    fix_excess(i)|
      ------|-------------|-----------------|-------
    */</span>  
</pre>
<pre><span class="operator">}</span><span class="keyword"> <br><br>template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type"> <br>void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fix_excess<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment"> <br>  //this node's child i has one too many items: 3 steps: <br>  //1. add a new subset at location i+1 of this node <br>  //2. split subset[i] (both the subset array and the data array) and move half into <br>  // subset[i+1] (this is the subset we created in step 1.) <br>  //3. detach the last data item of subset[i] and bring it and insert it into this node's data[] <br>  // //Note that this last step may cause this node to have too many items. This is OK. This will be <br>  // dealt with at the higher recursive level. (my parent will fix it!) </span><span class="operator"> <br>}<br><br></span></pre>
<pre><span class="type">void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>remove<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    //Loose_remove the entry from this tree.
    //once you return from loose_remove, the root (this object) may have no data and only a single subset
    //now, the tree must shrink:
    //  point a temporary pointer (shrink_ptr) and point it to this root's only subset
    //  copy all the data and subsets of this subset into the root (through shrink_ptr)
    //  now, the root contains all the data and poiners of it's old child.
    //  now, simply delete shrink_ptr (blank out child), and the tree has shrunk by one level.
    //  Note, the root node of the tree will always be the same, it's the child node we delete
</span><span class="operator">

}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>loose_remove<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
     /* four cases:
          a. leaf &amp;&amp; not found target: there is nothing to do
          b. leaf &amp;&amp; found target: just remove the target
          c. not leaf and not found target: recursive call to loose_remove
          d. not leaf and found: replace target with largest child of subset[i]

             |   !found    |   found       |
       ------|-------------|---------------|-------
       leaf  |  a: nothing | b: delete     |
             |     to do   |    target     |
       ------|-------------|---------------|-------
       !leaf | c: loose_   | d: replace    |
             |    remove   |    w/ biggest |
       ------|-------------|---------------|-------


     */</span><span class="operator">
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>fix_shortage<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * fix shortage in subtree i:
     * if child i+1 has more than MINIMUM, rotate left
     * elif child i-1 has more than MINIMUM, rotate right
     * elif there is a right child, merge child i with next child
     * else merge child i with left child
     */</span><span class="operator">

}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>remove_biggest<span class="operator">(</span>T<span class="operator">&amp;</span> entry<span class="operator">){</span><span class="comment">
    // Keep looking in the last subtree (recursive)
    //  until you get to a leaf.
    // Then, detach the last (biggest) data item
    //
    // after the recursive call, fix shortage.
</span><span class="operator">
}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>merge_with_next_subset<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     *  Merge subset[i] with subset [i+1] with data[i] in the middle
     *
     *   1. remove data[i] from this object
     *   2. append it to child[i]-&gt;data
     *   3. Move all data items from subset[i+1]-&gt;data to subset[i]-&gt;data
     *   4. Move all subset pointers from subset[i+1]-&gt;subset to subset[i]-&gt;subset
     *   5. delete subset[i+1] (store in a temp ptr)
     *   6. delete temp ptr
     */</span><span class="operator">

}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>rotate_left<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /*
     * (0 &lt; i &lt; child_count) and (subset[i]-&gt;data_count &gt; MINIMUM)
     * subset[i-1] has only MINIMUM - 1 entries.
     *
     * item transfers from child[i] to child [i-1]
     *
     * FIRST item of subset[i]-&gt;data moves up to data to replace data[i-1],
     * data[i-1] moves down to the RIGHT of subset[i-1]-&gt;data
     *
     *  i = 1:
     *              [50 100]
     *  [  ]        [65 75]       ....
     *            [a]  [b]  [c]
     *
     *  65 move up to replace 50 (data[i])
     *  65's child (its child 0) moves over to be the child of 50
     *  50 moves down to the right of subset[i]-&gt;data
     *
     *              [65 100]
     *  [50]         [ 75 ]       ....
     *     [a]      [b]  [c]
     *
     *
     *
     *<br>     */</span><span class="comment">
    // If necessary, shift first subset of subset[i] to end of subset[i-1]
</span><span class="operator">}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
void</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>rotate_right<span class="operator">(</span><span class="type">int</span> i<span class="operator">){</span><span class="comment">
    /* (i &lt; child_count - 1) and (subset[i]-&gt;data_count &gt; MINIMUM)
     * subset[i+ 1] has only MINIMUM - 1 entries.
     *
     * item transfers from child[i] to child [i+1]
     *
     * LAST item of subset[i]-&gt;data moves up to data to replace data[i],
     * data[i] moves down to the LEFT of subset[i+1]-&gt;data
     *
     * i = 1
     *                     [50 100]
     *      [20 30]        [65 75]          [ ]
     *  [..] [..] [..]   [a] [b] [c]        [..]
     *
     *  75 moves up to replace 100 (data[i])
     *  75's child (its last child) moves over to be the (child 0) child of 100
     *  100 moves down to subset[i]-&gt;data
     *
     *                     [50 75]
     *      [20 30]          [65]          [100]
     *  [..] [..] [..]     [a] [b]        [c] [..]
     *
     *
     *
     *
     * <br>     */</span><span class="comment">
    // If necessary, shift last subset of subset[i] to front of subset[i+1]
</span><span class="operator">
}</span>
</pre>
<p>&nbsp;</p>
<p>Here is the summary of <strong>get</strong>, &nbsp;<strong>contains</strong>, and <strong>find</strong> member functions:</p>
<pre><span class="comment">//---------------------------------------------------------------------
//            C O N T A I N S / F I N D / G E T / E T C .
//---------------------------------------------------------------------
</span><span class="keyword">template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span><span class="type">
bool</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>contains<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){

}</span><span class="keyword">
template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
T<span class="operator">*</span> BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>find<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){
    
}</span><span class="keyword">

template</span><span class="operator"> &lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
T<span class="operator"> &amp;</span>BTree<span class="operator">&lt;</span>T<span class="operator">&gt;::</span>get<span class="operator">(</span><span class="keyword">const</span> T<span class="operator">&amp;</span> entry<span class="operator">){<br>     if (!contains(entry)) <br>         insert(entry); <br><br>     return get_existing(entry); </span>
<span class="operator">}</span><span class="operator"><br><br></span></pre>
<h3><strong>TESTING:</strong></h3>
<p>Please see&nbsp;&nbsp;<a title="BTree / B+Tree main.cpp" href="$CANVAS_OBJECT_REFERENCE$/assignments/ga4474f01023a853caf72a7385dbd2d3e" data-api-endpoint="https://canvas.pasadena.edu/api/v1/courses/1115180/assignments/8761012" data-api-returntype="Assignment">BTree / B+Tree main.cpp</a></p>
<h3><strong>BPlusTree ARRAY FUNCTIONS:</strong></h3>
<p>&nbsp;Please see&nbsp;<a title="BTree / B+Tree Array Functions" href="$CANVAS_OBJECT_REFERENCE$/assignments/g457ae23160ba36e264e154e734bbcbff" data-api-endpoint="https://canvas.pasadena.edu/api/v1/courses/1115180/assignments/8761011" data-api-returntype="Assignment">BTree / B+Tree Array Functions</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</body>
</html>